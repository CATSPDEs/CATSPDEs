#pragma once
#include "AbstractQuadratureRule.hpp"

// quad rule for master segment := [-1, 1]
class MasterSegmentQuadratureRule
	: public AbstractQuadratureRule<1> {
	// singleton
	MasterSegmentQuadratureRule() : AbstractQuadratureRule {
		// (1) nodes (n := polynomial order)
		{
			// n = 0
			{ -.577350269189626, .577350269189626 },
			// n = 1
			{ -.577350269189626, .577350269189626 },
			// n = 2
			{ -.577350269189626, .577350269189626 },
			// n = 3
			{ -.577350269189626, .577350269189626 },
			// n = 4
			{ -.774596669241483, 0., .774596669241483 },
			// n = 5
			{ -.774596669241483, 0., .774596669241483 },
			// n = 6
			{ -.906179845938664, -.538469310105683, 0., .538469310105683, .906179845938664 },
			// n = 7
			{ -.906179845938664, -.538469310105683, 0., .538469310105683, .906179845938664 },
			// n = 8
			{ -.906179845938664, -.538469310105683, 0., .538469310105683, .906179845938664 },
			// n = 9
			{ -.906179845938664, -.538469310105683, 0., .538469310105683, .906179845938664 }
		},
		// (2) weights
		{ 
			// n = 0
			{ 1., 1. },
			// n = 1
			{ 1., 1. },
			// n = 2
			{ 1., 1. },
			// n = 3
			{ 1., 1. },
			// n = 4
			{ .555555555555556, .888888888888889, .555555555555556 },
			// n = 5
			{ .555555555555556, .888888888888889, .555555555555556 },
			// n = 6
			{ .236926885056189, .478628670499366, .568888888888889, .478628670499366, .236926885056189 },
			// n = 7
			{ .236926885056189, .478628670499366, .568888888888889, .478628670499366, .236926885056189 },
			// n = 8
			{ .236926885056189, .478628670499366, .568888888888889, .478628670499366, .236926885056189 },
			// n = 9
			{ .236926885056189, .478628670499366, .568888888888889, .478628670499366, .236926885056189 }
		}
	}
	{}
	MasterSegmentQuadratureRule(MasterSegmentQuadratureRule const &);
	MasterSegmentQuadratureRule& operator=(MasterSegmentQuadratureRule const &);
public:
	static auto& instance() {
		static MasterSegmentQuadratureRule single;
		return single;
	}
};